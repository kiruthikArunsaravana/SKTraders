/**
 * @fileoverview Firestore Security Rules for SK Traders application.
 *
 * Core Philosophy:
 * This ruleset prioritizes simplicity by delegating authorization to the backend (Spring Security).
 * It avoids complex Firestore rules and authorization denormalization. Access to collections
 * is generally open, with the expectation that Spring Security will enforce role-based access
 * control on the server side.
 *
 * Data Structure:
 * The Firestore database uses a flat structure with top-level collections for each entity:
 * /clients/{clientId}, /products/{productId}, /stocks/{stockId}, /sales/{saleId},
 * /purchases/{purchaseId}, /receipts/{receiptId}, /expenses/{expenseId}, /exports/{exportId}.
 *
 * Key Security Decisions:
 * - Role-based access control is handled by Spring Security on the backend, not in these rules.
 * - All collections are generally readable and writable by any authenticated user.
 * - No user-specific data or subcollections are used.
 * - Listing collections is allowed for any authenticated user.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages access to client data.
     * @path /clients/{clientId}
     * @allow (get, list) Any authenticated user can read client data.
     * @allow (create, update, delete) Any authenticated user can modify client data.
     * @deny None. Access control is enforced on the backend.
     * @principle Access control is managed on the backend via Spring Security.
     */
    match /clients/{clientId} {
      allow get, list: if isSignedIn();
      allow create, update, delete: if isSignedIn();
    }

    /**
     * @description Manages access to product data.
     * @path /products/{productId}
     * @allow (get, list) Any authenticated user can read product data.
     * @allow (create, update, delete) Any authenticated user can modify product data.
     * @deny None. Access control is enforced on the backend.
     * @principle Access control is managed on the backend via Spring Security.
     */
    match /products/{productId} {
      allow get, list: if isSignedIn();
      allow create, update, delete: if isSignedIn();
    }

    /**
     * @description Manages access to stock data.
     * @path /stocks/{stockId}
     * @allow (get, list) Any authenticated user can read stock data.
     * @allow (create, update, delete) Any authenticated user can modify stock data.
     * @deny None. Access control is enforced on the backend.
     * @principle Access control is managed on the backend via Spring Security.
     */
    match /stocks/{stockId} {
      allow get, list: if isSignedIn();
      allow create, update, delete: if isSignedIn();
    }

    /**
     * @description Manages access to sales data.
     * @path /sales/{saleId}
     * @allow (get, list) Any authenticated user can read sales data.
     * @allow (create, update, delete) Any authenticated user can modify sales data.
     * @deny None. Access control is enforced on the backend.
     * @principle Access control is managed on the backend via Spring Security.
     */
    match /sales/{saleId} {
      allow get, list: if isSignedIn();
      allow create, update, delete: if isSignedIn();
    }

    /**
     * @description Manages access to purchase data.
     * @path /purchases/{purchaseId}
     * @allow (get, list) Any authenticated user can read purchase data.
     * @allow (create, update, delete) Any authenticated user can modify purchase data.
     * @deny None. Access control is enforced on the backend.
     * @principle Access control is managed on the backend via Spring Security.
     */
    match /purchases/{purchaseId} {
      allow get, list: if isSignedIn();
      allow create, update, delete: if isSignedIn();
    }

    /**
     * @description Manages access to receipt data.
     * @path /receipts/{receiptId}
     * @allow (get, list) Any authenticated user can read receipt data.
     * @allow (create, update, delete) Any authenticated user can modify receipt data.
     * @deny None. Access control is enforced on the backend.
     * @principle Access control is managed on the backend via Spring Security.
     */
    match /receipts/{receiptId} {
      allow get, list: if isSignedIn();
      allow create, update, delete: if isSignedIn();
    }

    /**
     * @description Manages access to expense data.
     * @path /expenses/{expenseId}
     * @allow (get, list) Any authenticated user can read expense data.
     * @allow (create, update, delete) Any authenticated user can modify expense data.
     * @deny None. Access control is enforced on the backend.
     * @principle Access control is managed on the backend via Spring Security.
     */
    match /expenses/{expenseId} {
      allow get, list: if isSignedIn();
      allow create, update, delete: if isSignedIn();
    }

    /**
     * @description Manages access to export data.
     * @path /exports/{exportId}
     * @allow (get, list) Any authenticated user can read export data.
     * @allow (create, update, delete) Any authenticated user can modify export data.
     * @deny None. Access control is enforced on the backend.
     * @principle Access control is managed on the backend via Spring Security.
     */
    match /exports/{exportId} {
      allow get, list: if isSignedIn();
      allow create, update, delete: if isSignedIn();
    }

    /**
     * @description Manages access to financial_transactions data. Since access was denied due to the rules, and since there is no entity defined for it, the least priviledge principle is used by denying all access
     * @path /financial_transactions
     */
    match /financial_transactions {
        allow get, list, create, update, delete: if false;
    }

  }

  function isSignedIn() {
    return request.auth != null;
  }
}